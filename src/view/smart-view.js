import Abstract from './abstract';

// так нам надо будет обновлять состояние не только вьюх формы редактирования и карточки поездки, но и некоторых других,
// то имеет смысл вынести эту логику в отдельный класс
export default class AbstractSmartView extends Abstract {
  constructor() {
    super();
    // в конструкторе сразу будем заводить свойство, в которое впоследствии будем записывать состояние соответ. вьюхи
    // p.s. свойство взято "не с потолка": в классе TripPointEditFormView мы как раз в конструкторе сэтили такое свойство
    this._stateData = {};
  }

  // Внимание! Методы updateElementMarkup и updateState ранее находились в классе TripPointEditFormView, но так как
  // это общие по смыслу методы для работы со всеми вьюхами, то разумно вынести их в общий класс и
  // всем желающим уже наследоваться от него.

  // Научим наш компонент обновлять свою разметку
  updateElementMarkup() {
    // получаем ссылку на текущий DOM-элемент (то есть получается, что на данном этапе у нас и в this._element,
    // и в oldElement "лежит" ссылка на один и тот же DOM-элемент)
    const oldElement = this.getElement();
    // получаем ссылку на DOM-родителя
    const oldElementParent = oldElement.parentElement;
    // в нашем самописном API класса Abstract метод removeElement присваивает this._element = null
    // и хотя this._element больше не ссылается на DOM-элемент, эта ссылка всё ещё есть в oldElement, то есть
    // физически DOM-элемент, несмотря на вызов removeElement, всё ещё существует
    this.removeElement();

    // вызываем getElement у this и так как к этому моменту this._element = null, то происходит полная повторная генерация
    // разметки. А так как getElement "дёргает" getTemplate, а в getTemplate первым аргументом приходит this._stateData,
    // то если мы перед вызовом updateElementMarkup заблаговременно вызовем метод, который обновит this._stateData, то на
    // выходе мы получим DOM-элемент с изменившейся разметкой
    const newElement = this.getElement();

    // а дальше API ЖабаСкрипта позволяет нам произвести замену старого элемента (который мы в самом начале метода "забэкапили"
    // на новый с обновлённой разметкой
    oldElementParent.replaceChild(newElement, oldElement);

    // и так как мы полностью перерисовали разметку всего элемента, то обработчики "сломались" и нужно их переподписать
    this.restoreHandlers();
    //console.log('Произошла полная повторная генерация разметки на основании текущего this._stateData');
  }

  // Научим наш компонент обновлять своё состояние:
  // для этого объявим метод, в который будет передавать объект с обновлёнными свойствами (это может быть только часть
  // объекта, если обновилось, например, только одно свойство)
  updateState(update, localStateUpdate) {
    // делаем проверку на случай передачи пустого объекта (если пустой - ничего не обновляем)
    if (!update) {
      return;
    }

    // сначала обновляем состояние вьюхи (обновлённые данные в объекте СОВМЕСТИМОГО - то есть имеющего те же пары "ключ - значение"
    // update)
    this._stateData = Object.assign(
      {},
      this._stateData,
      update,
    );

    // добавляем проверку на тот случай, когда у нас локальное обновление состояния вьюхи без полной перерисовки
    // полная перерисовка вьюхи с полным обновлением её разметки нам требуется только в ОДНОМ СЛУЧАЕ: когда пользователь
    // делает сабмит формы
    // p.s. сейчас мы не рассматриваем ситуацию, когда обновление приходит со стороны модели - этой связи у нас пока нет
    if (localStateUpdate) {
      return;
    }

    // и только если все проверки пройдены (то есть пришёл какой-то не пустой объект и флаг localStateUpdate = false)
    // мы полностью обновляем разметку вьюхи
    this.updateElementMarkup();
  }

  // то же (имеется в виду вынос метода в общий класс) касается и метода restoreHandlers, но с одним существенным
  // отличием: в данном случае объявление метода в абстрактном классе нужно для контракта - классы, которые расширяют этот
  // класс и которые захотят воспользоваться этим методом "упадут" с ошибкой - они должны этот метод реализовать сами
  restoreHandlers() {
    throw new Error('Abstract method not implemented: restoreHandlers');
  }
}
